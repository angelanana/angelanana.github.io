<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue3组合式API最新实践</title>
    <link href="/2025/04/01/Vue3%E7%BB%84%E5%90%88%E5%BC%8FAPI%E6%9C%80%E6%96%B0%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/04/01/Vue3%E7%BB%84%E5%90%88%E5%BC%8FAPI%E6%9C%80%E6%96%B0%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Vue3组合式API是Vue3引入的一种新的API风格，它通过将组件的逻辑拆分为多个可重用的函数，使得组件的代码更加清晰、可维护和可测试。本文将介绍Vue3组合式API的最新实践，包括最佳实践、性能优化和未来发展趋势。</p><h1 id="一、为什么组合式API是Vue3的革命性升级"><a href="#一、为什么组合式API是Vue3的革命性升级" class="headerlink" title="一、为什么组合式API是Vue3的革命性升级"></a>一、为什么组合式API是Vue3的革命性升级</h1><h2 id="1-1-选项式API的痛点"><a href="#1-1-选项式API的痛点" class="headerlink" title="1.1 选项式API的痛点"></a>1.1 选项式API的痛点</h2><ul><li><strong>代码碎片化：</strong>数据在 <code>data</code>，方法在 <code>methods</code>，计算属性在<code>computed</code>，生命周期钩子在 <code>mounted</code> 等选项中分散。</li><li><strong>逻辑耦合：</strong>1000行组件中去找关联逻辑如同大海捞针。</li><li><strong>可维护性差：</strong>Mixins存在命名冲突和来源不清晰问题。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 传统Options API（用户管理组件）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span> () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">users</span>: [],<br>      <span class="hljs-attr">filters</span>: &#123;&#125;,<br>      <span class="hljs-attr">pagination</span>: &#123;&#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">fetchUsers</span> () &#123;<br>      <span class="hljs-comment">// 实现用户数据获取逻辑</span><br>    &#125;,<br>    <span class="hljs-title function_">deleteUsers</span> () &#123;<br>      <span class="hljs-comment">// 实现用户过滤逻辑</span><br>    &#125;,<br>    <span class="hljs-title function_">handlePagination</span> () &#123;<br>      <span class="hljs-comment">// 实现分页逻辑</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">filteredUsers</span> () &#123;<br>      <span class="hljs-comment">// 实现用户过滤计算</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">filters</span>: &#123;<br>      <span class="hljs-title function_">handler</span> () &#123;<br>        <span class="hljs-comment">// 实现用户过滤监听</span><br>      &#125;,<br>      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-组合式API的三大优势"><a href="#1-2-组合式API的三大优势" class="headerlink" title="1.2 组合式API的三大优势"></a>1.2 组合式API的三大优势</h2><ul><li><strong>逻辑聚合：</strong>按功能而非选项组织代码</li><li><strong>完美复用：</strong>函数式封装实现”即插即用”</li><li><strong>类型支持：</strong>天然适配TypeScript<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用组合式API重构</span><br><span class="hljs-keyword">import</span> &#123; useUserFetch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./composables/userFetch&#x27;</span><br><span class="hljs-keyword">import</span> &#123; useTableFilter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./composables/tableFilter&#x27;</span><br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; users, fetchUsers &#125; = <span class="hljs-title function_">useUserFetch</span>()<br>    <span class="hljs-keyword">const</span> &#123; filteredData, filters &#125; = <span class="hljs-title function_">useTableFilter</span>(users)<br>    <br>    <span class="hljs-keyword">return</span> &#123; users, filteredData, filters, fetchUsers &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><!-- 引入对比图 --><img src="/images/Vue2vsVue3.png" alt="图片"></li></ul><h1 id="二、组合式API核心机制深度剖析（附完整代码）"><a href="#二、组合式API核心机制深度剖析（附完整代码）" class="headerlink" title="二、组合式API核心机制深度剖析（附完整代码）"></a>二、组合式API核心机制深度剖析（附完整代码）</h1><h2 id="2-1-setup函数：新世界的入口"><a href="#2-1-setup函数：新世界的入口" class="headerlink" title="2.1 setup函数：新世界的入口"></a>2.1 setup函数：新世界的入口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>// 编译器语法糖<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>function increment() &#123;<br>  count.value++<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>关键细节：</strong></p><ul><li><strong>执行时机</strong>：在<code>beforeCreate</code>之前</li><li><strong>参数解析</strong>：<code>props</code>是响应式的，不用解构</li><li><strong>Context对象</strong>：包含<code>attrs</code> &#x2F; <code>slots</code> &#x2F; <code>emit</code>等</li></ul><h2 id="2-2-ref-vs-reactive-选择指南"><a href="#2-2-ref-vs-reactive-选择指南" class="headerlink" title="2.2 ref() vs reactive() 选择指南"></a>2.2 ref() vs reactive() 选择指南</h2><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>基础类型数据</td><td><code>ref()</code></td><td>自动解包，模板使用更方便</td></tr><tr><td>复杂对象&#x2F;数组</td><td><code>reactive()</code></td><td>深层响应式，性能更优</td></tr><tr><td>第三方类实例</td><td><code>reactive()</code></td><td>保持原型链方法</td></tr><tr><td>跨组件状态共享</td><td><code>ref()</code> + <code>provide/inject</code></td><td>响应式追踪更可控</td></tr></tbody></table><p><strong>ref的底层原理</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 深响应式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params">value?: unknown</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRef</span>(value, <span class="hljs-literal">false</span>)<br>&#125;<br><br><span class="hljs-comment">// 浅响应式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowRef</span>(<span class="hljs-params">value?: unknown</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRef</span>(value, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRef</span>(<span class="hljs-params">rawValue: unknown, shallow: boolean</span>) &#123;<br>  <span class="hljs-comment">// 如果传入的值已经是一个 ref，则直接返回它</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isRef</span>(rawValue)) &#123;<br>    <span class="hljs-keyword">return</span> rawValue<br>  &#125;<br>  <span class="hljs-comment">// 否则，创建一个新的 RefImpl 实例</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefImpl</span>(rawValue, shallow)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefImpl</span>&lt;T&gt; &#123;<br>  <span class="hljs-comment">// 存储响应式的值。我们追踪和更新的就是_value。（这个是重点）</span><br>  private <span class="hljs-attr">_value</span>: T<br>  <span class="hljs-comment">// 用于存储原始值，即未经任何响应式处理的值。（用于对比的，这块的内容可以不看）</span><br>  private <span class="hljs-attr">_rawValue</span>: T <br><br>  <span class="hljs-comment">// 用于依赖跟踪的 Dep 类实例</span><br>  public dep?: <span class="hljs-title class_">Dep</span> = <span class="hljs-literal">undefined</span><br>  <span class="hljs-comment">// 一个标记，表示这是一个 ref 实例</span><br>  public readonly __v_isRef = <span class="hljs-literal">true</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    value: T,</span><br><span class="hljs-params">    public readonly __v_isShallow: boolean,</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-comment">// 如果是浅响应式，直接使用原始值，否则转换为非响应式原始值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rawValue</span> = __v_isShallow ? value : <span class="hljs-title function_">toRaw</span>(value)<br>    <span class="hljs-comment">// 如果是浅响应式，直接使用原始值，否则转换为响应式值</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = __v_isShallow ? value : <span class="hljs-title function_">toReactive</span>(value)<br>    <br>    <span class="hljs-comment">// toRaw 用于将响应式引用转换回原始值</span><br>    <span class="hljs-comment">// toReactive 函数用于将传入的值转换为响应式对象。对于基本数据类型，toReactive 直接返回原始值。</span><br>    <span class="hljs-comment">// 对于对象和数组，toReactive 内部会调用 reactive 来创建一个响应式代理。</span><br>    <span class="hljs-comment">// 因此，对于 ref 来说，基本数据类型的值会被 RefImpl 直接包装，而对象和数组</span><br>    <span class="hljs-comment">// 会被 reactive 转换为响应式代理，最后也会被 RefImpl 包装。</span><br>    <span class="hljs-comment">// 这样，无论是哪种类型的数据，ref 都可以提供响应式的 value 属性，</span><br>    <span class="hljs-comment">// 使得数据变化可以被 Vue 正确追踪和更新。</span><br>    <span class="hljs-comment">// export const toReactive = (value) =&gt; isObject(value) ? reactive(value) : value</span><br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-comment">// 追踪依赖，这样当 ref 的值发生变化时，依赖这个 ref 的组件或副作用函数可以重新运行。</span><br>    <span class="hljs-title function_">trackRefValue</span>(<span class="hljs-variable language_">this</span>)<br>    <span class="hljs-comment">// 返回存储的响应式值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span><br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newVal</span>) &#123;<br>    <span class="hljs-comment">// 判断是否应该使用新值的直接形式（浅响应式或只读）</span><br>    <span class="hljs-keyword">const</span> useDirectValue =<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">__v_isShallow</span> || <span class="hljs-title function_">isShallow</span>(newVal) || <span class="hljs-title function_">isReadonly</span>(newVal)<br>    <span class="hljs-comment">// 如果需要，将新值转换为非响应式原始值</span><br>    newVal = useDirectValue ? newVal : <span class="hljs-title function_">toRaw</span>(newVal)<br>    <span class="hljs-comment">// 如果新值与旧值不同，更新 _rawValue 和 _value</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasChanged</span>(newVal, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rawValue</span>)) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rawValue</span> = newVal<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = useDirectValue ? newVal : <span class="hljs-title function_">toReactive</span>(newVal)<br>      <span class="hljs-comment">// 触发依赖更新</span><br>      <span class="hljs-title function_">triggerRefValue</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">DirtyLevels</span>.<span class="hljs-property">Dirty</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ref是一个函数，它接收一个内部值并且返回一个响应式且可变的引用对象。这个引用对象有一个<code>.value</code>属性，这个属性指向内部值。</p><p><strong>reactive的底层原理</strong><br><code>reactive</code>是一个函数，它接受一个对象并返回该对象的响应式代理，也就是<code>proxy</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) &#123;<br>  <span class="hljs-keyword">if</span> (target &amp;&amp; target.<span class="hljs-property">__v_isReactive</span>) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactiveObject</span>(<br>    target,<br>    <span class="hljs-literal">false</span>,<br>    mutableHandlers,<br>    mutableCollectionHandlers,<br>    reactiveMap<br>  )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params"></span><br><span class="hljs-params">  target,</span><br><span class="hljs-params">  isReadonly,</span><br><span class="hljs-params">  baseHandlers,</span><br><span class="hljs-params">  collectionHandlers,</span><br><span class="hljs-params">  proxyMap</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(target)) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> existingProxy = proxyMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (existingProxy) &#123;<br>    <span class="hljs-keyword">return</span> existingProxy<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, baseHandlers)<br>  proxyMap.<span class="hljs-title function_">set</span>(target, proxy)<br>  <span class="hljs-keyword">return</span> proxy<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reactive</code>的源码简单很多，<code>reactive</code>通过<code>new Proxy(target, baseHandlers)</code> 创建了一个代理。这个代理会拦截对目标对象的操作，从而实现响应式。</p><p>具体的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br>state.<span class="hljs-property">count</span>++<br></code></pre></td></tr></table></figure><p>可以看出ref和reactive的区别：</p><ul><li>底层原理不一样</li><li><code>ref</code>采用<code>RefImpl</code>实现，<code>reactive</code>则采用<code>Proxy</code>实现</li></ul><h3 id="ref更深入的理解"><a href="#ref更深入的理解" class="headerlink" title="ref更深入的理解"></a>ref更深入的理解</h3><p>当你使用 <code>new RefImpl(value)</code> 创建一个 <code>RefImpl</code> 实例时，实际上发生了以下几个步骤：</p><ol><li><strong>内部值</strong>：实例存储了传递给构造函数的初始值。</li><li><strong>依赖收集</strong>：实例需要跟踪所有依赖于他的效果（effect），例如计算属性或者副作用函数。通常通过一个依赖列表或函数来实现。</li><li><strong>触发更新</strong>：当实例的值发生变化时，它需要通知所有依赖它的效果进行更新，以便他们可以重新计算或执行。</li></ol><p>RefImpl 类似于发布-订阅模式的设计，以下是一个简化的<code>RefImpl</code>类的伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (activeEffect) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">add</span>(activeEffect);<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watchEffect</span>(<span class="hljs-params">effect</span>) &#123;<br>  activeEffect = effect;<br>  <span class="hljs-title function_">effect</span>();<br>  activeEffect = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefImpl</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-comment">// 当获取值时，进行依赖收集</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span>.<span class="hljs-title function_">depend</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-keyword">if</span> (newValue !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = newValue;<br>      <span class="hljs-comment">// 值改变时，触发更新</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用实例</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefImpl</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Effect 1:&#x27;</span>, count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 订阅变化</span><br>&#125;)<br>count.<span class="hljs-property">value</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 触发更新</span><br></code></pre></td></tr></table></figure><p>Dep类负责管理一个依赖列表，并提供依赖收集和通知更新的功能；RefImpl类包含一个内部值_value和一个Dep实例。当value被访问时，通过get方法进行依赖收集；当value被赋予新值时，通过set方法触发更新。</p><h3 id="reactive的局限性"><a href="#reactive的局限性" class="headerlink" title="reactive的局限性"></a>reactive的局限性</h3><p>Vue3中，reactive API 通过 proxy实现了一种响应式数据的方式，尽管这种方法在性能上比vue2有所提升，但proxy的局限性也导致了reactive的局限性，这些局限性会影响开发者的使用体验。<br>1.仅对引用数据类型有效<br>reactive 主要适用于对象，包括数组和一些集合类型（如：Map和Set）。对于基础数据类型（如：string、number、boolean），reactive 无法直接响应。<br>2.使用不当会失去响应</p><ul><li>直接赋值对象，失去响应性</li><li>直接替换响应对象，失去响应性</li><li>直接解构对象，会失去响应性。解决：用toRefs函数来将响应式对象转换为ref对象</li><li>将响应式对象的属性赋值给变量，会失去响应式</li></ul><h1 id="高级实战技巧"><a href="#高级实战技巧" class="headerlink" title="高级实战技巧"></a>高级实战技巧</h1><h2 id="3-1-通用数据请求封装"><a href="#3-1-通用数据请求封装" class="headerlink" title="3.1 通用数据请求封装"></a>3.1 通用数据请求封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// useFetch.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useFetch</span> = (<span class="hljs-params">url</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(url)<br>      data.<span class="hljs-property">value</span> = response.<span class="hljs-property">data</span><br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      error.<span class="hljs-property">value</span> = err<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">onMounted</span>(fetchData)<br>  <span class="hljs-keyword">return</span> &#123; data, error, loading, <span class="hljs-attr">retry</span>: fetchData &#125;<br>&#125;<br><br><span class="hljs-comment">// 组件中使用</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: posts &#125; = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">&#x27;/api/posts&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-2-防抖探索实战"><a href="#3-2-防抖探索实战" class="headerlink" title="3.2 防抖探索实战"></a>3.2 防抖探索实战</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// useDebounceSearch.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useDebounceSearch</span>(<span class="hljs-params">callback, delay=<span class="hljs-number">500</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> searchQuery = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">let</span> timeoutId = <span class="hljs-literal">null</span><br><br>  <span class="hljs-title function_">watch</span>(searchQuery, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeoutId)<br>    timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">callback</span>(newVal)<br>    &#125;, delay)<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> &#123; searchQuery &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="性能优化最佳实践"><a href="#性能优化最佳实践" class="headerlink" title="性能优化最佳实践"></a>性能优化最佳实践</h1><h2 id="4-1-计算属性缓存策略"><a href="#4-1-计算属性缓存策略" class="headerlink" title="4.1 计算属性缓存策略"></a>4.1 计算属性缓存策略</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filteredList = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过闭包缓存中间结果</span><br>  <span class="hljs-keyword">const</span> cached = &#123;&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">filterKey</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(cache[filterKey]) <span class="hljs-keyword">return</span> cache[filterKey]<br>    <span class="hljs-keyword">return</span> cache[filterKey] = <span class="hljs-title function_">heavyCompute</span>()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="4-2-watchEffect-的高级用法"><a href="#4-2-watchEffect-的高级用法" class="headerlink" title="4.2 watchEffect()的高级用法"></a>4.2 watchEffect()的高级用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即执行+自动追踪依赖</span><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">fetchData</span>(params.<span class="hljs-property">value</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;依赖自动追踪：&#x27;</span>,data)<br>&#125;, &#123;<br>  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-comment">// DOM更新后执行</span><br>  <span class="hljs-title function_">onTrack</span>(<span class="hljs-params">e</span>) &#123;&#125; <span class="hljs-comment">// 调试追踪</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="4-3-内催泄露防范"><a href="#4-3-内催泄露防范" class="headerlink" title="4.3 内催泄露防范"></a>4.3 内催泄露防范</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定时器示例</span><br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;...&#125;, <span class="hljs-number">1000</span>)<br>  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer))<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="TypeScript终级适配方案"><a href="#TypeScript终级适配方案" class="headerlink" title="TypeScript终级适配方案"></a>TypeScript终级适配方案</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">interface <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">name</span>: string<br>  <span class="hljs-attr">age</span>: number,<br>  <span class="hljs-attr">id</span>: number<br>&#125;<br><br><span class="hljs-comment">// 带类型的Ref</span><br><span class="hljs-keyword">const</span> user = ref&lt;<span class="hljs-title class_">User</span>&gt;(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>&#125;)<br><br><span class="hljs-comment">// 组合函数类型定义</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params"></span>): &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-title class_">Ref</span>&lt;number&gt;<br>  <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span><br>&#125; &#123;<br>  <span class="hljs-comment">// 实现逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你对这篇文章有任何疑问、建议或者独特的见解，欢迎在评论区留言。无论是探讨技术细节，还是分享项目经验，都能让我们共同进步。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angelanana | Full-stack Explorer</title>
    <link href="/2025/01/03/me/"/>
    <url>/2025/01/03/me/</url>
    
    <content type="html"><![CDATA[<div class="bio-container">  <div class="lang-section cn">  <h3 id="👩💻-技术轨迹"><a href="#👩💻-技术轨迹" class="headerlink" title="👩💻 技术轨迹"></a>👩💻 技术轨迹</h3><p><strong>全栈工程师</strong> | <strong>开源贡献者</strong> | <strong>终身学习者</strong></p><p><strong>2020-2025</strong> 前端领域深度实践者：</p><ul><li><strong>核心领域</strong>：Vue2&#x2F;3全栈方案、Nuxt服务端渲染、Electron桌面开发</li><li><strong>技术生态</strong>：NestJS企业级框架、Node中间件开发、Webpack&#x2F;Vite工程化体系</li><li><strong>架构实践</strong>：主导5+中后台系统，设计跨项目组件库，参与华为开源组件开发</li></ul><p><strong>技术里程碑</strong>：</p><ul><li><p>🏆 2022年华为DevUI开源贡献者，主导面包屑导航、树形选择组件开发（10+项目采用）</p></li><li><p>🚀 构建企业级组件库架构，开发效率提升40%，编制《Vue3组合式API最佳实践》</p></li><li><p>🔥 2025年完成Nuxt3项目重构，首屏性能优化至LCP 0.8s（下降62%）</p></div><div class="lang-section en"></li></ul><h3 id="👩💻-Tech-Odyssey"><a href="#👩💻-Tech-Odyssey" class="headerlink" title="👩💻 Tech Odyssey"></a>👩💻 Tech Odyssey</h3><p><strong>Full-stack Engineer</strong> | <strong>OSS Contributor</strong> | <strong>Lifelong Learner</strong></p><p><strong>2020-2025</strong> Frontend Specialist:</p><ul><li><strong>Core Stack</strong>: Vue2&#x2F;3 Full Solutions, Nuxt SSR, Electron Desktop Dev</li><li><strong>Tech Ecosystem</strong>: NestJS Enterprise Framework, Node Middleware, Webpack&#x2F;Vite Tooling</li><li><strong>Architecture</strong>: Led 5+ Admin Systems, Designed Cross-project Component Library, Contributed to Huawei OSS</li></ul><p><strong>Milestones</strong>:</p><ul><li><p>🏆 2022 Huawei DevUI Contributor (Breadcrumb &amp; TreeSelect components adopted by 10+ projects)</p></li><li><p>🚀 Built enterprise component library boosting 40% dev efficiency, authored《Vue3 Composition API Best Practices》</p></li><li><p>🔥 2025 Nuxt3 SSR optimization achieving 0.8s LCP (62% improvement)</p></div></li></ul></div><style>.bio-container {display: flex; gap: 40px; margin: 2rem 0;}.lang-section {flex: 1;}.lang-section.cn h3 {color: #2c3e50;}.lang-section.en h3 {color: #34495e;}@media (max-width: 768px) {  .bio-container {flex-direction: column;}}</style><p>🛠️ <strong>技术聚焦 | Tech Focus</strong></p><ul><li>WebAssembly性能优化实践 &#x2F; WebAssembly Performance Optimization</li><li>NestJS微服务架构 &#x2F; NestJS Microservices</li><li>Monorepo工程化方案 &#x2F; Turborepo Monorepo Solutions</li></ul><p>🌱 <strong>成长之道 | Growth Philosophy</strong></p><ul><li><strong>技术纵深</strong>：年投入300+h刻意练习，系统补足CS核心知识 &#x2F; Annual 300+h deliberate practice on CS fundamentals</li><li><strong>跨界融合</strong>：在职考研锻造高效时间管理 &#x2F; Enhanced time management through part-time grad prep</li><li><strong>思维升级</strong>：普拉提教学实践启发技术架构设计 &#x2F; Pilates teaching inspires systematic technical design</li></ul><p>🎹 <strong>生活维度 | Life Palette</strong></p><ul><li>钢琴15年演奏 &#x2F; 15 years of piano performance experience</li><li>北极星普拉提认证（备考中）&#x2F; Polestar Pilates Certification (In-Progress)</li><li>2024书单：《马斯克传》《超越百岁》《我在北京送快递》&#x2F; 2024 Reads: Elon Musk, Outlive, Delivery Diaries</li></ul><p>📮 <strong>Connect | 期待交流</strong><br><a href="https://github.com/angelanana">GitHub</a> | <a href="https://juejin.cn/user/2463372060667735">掘金</a> | <a href="https://x.com/angelanana17894">X</a><br><em>“Stay hungry, stay foolish. 在比特与字节的世界，我们永远都是新生”</em><br><em>“Stay hungry, stay foolish. In the realm of bits and bytes, we remain perpetual learners.”</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>Frontend Development</tag>
      
      <tag>Vue Ecosystem</tag>
      
      <tag>Open Source</tag>
      
      <tag>Tech Growth</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
